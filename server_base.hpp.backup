/*
 * server_base.hpp
 * web server fream
 * create by chenlin
 * email:chenlin2844@hotmail.com
 */

#ifndef SERVER_BASE_HPP
#define SERVER_BASE_HPP

#include <boost/asio.hpp>
#include <regex>
#include <unordered_map>
#include <thread>
namespace webX{
	//为了解析客户端的请求
	struct Request{
		//请求方法，请求路径，HTTP版本
		std::string method, path, http_version;
		std::shared_ptr<std::istream> content;
		std::unordered_map<std::string,std::string> header;
		std::smatch path_match;//用正则表达式处理路径匹配
	};

	/*
	 * 服务器资源类型
	 */
	typedef std::map<std::string,std::unordered_map<std::string,
			std::function<void(std::ostream&, Request&)>>> resource_type;

	//socket_type:http/https
	template <typename socket_type>
		class ServerBase{
			public:
				ServerBase(unsigned short port, size_t num_threads = 1):
					endpoint(boost::asio::ip::tcp::v4(),port),
					acceptor(m_io_service,endpoint),
					num_threads(num_threads){}
				resource_type resource;	//用于服务器访问资源处理方式
				resource_type default_resource;	//用于保存默认的资源处理方式
				void start();
				
			protected:
				std::vector<resource_type::iterator> all_resources;	//用于内部实现对所有资源的处理
				//实现异步读写
				boost::asio::io_service m_io_service;
				boost::asio::ip::tcp::endpoint endpoint;
				boost::asio::ip::tcp::acceptor acceptor;	

				size_t num_threads;	//线程数
				std::vector<std::thread> threads;	//线程池
				
				
							
				//need to be implemented by child class
				virtual void accept(){}
				void process_request_and_respond(std::shared_ptr<socket_type> socket)const;
				Request parse_request(std::istream & stream)const;
				void respond(std::shared_ptr<socket_type> socket, std::shared_ptr<Request> request)const;
		};
	template <typename socket_type>
	void ServerBase<socket_type>::start(){
		//添加资源
		for(auto it = resource.begin();it!=resource.end();it++){
			all_resources.push_back(it);
		}
		for(auto it = default_resource.begin();it!=default_resource.end();it++){
			all_resources.push_back(it);
		}
		//建立socket连接,子类自行处理连接
		accept();
		//开启线程
		for(size_t c = 1;c<num_threads;c++){
			threads.emplace_back([this](){
					m_io_service.run();
					});
		}
		//主线程
		m_io_service.run();

		//等待其他线程
		for(auto &t :threads){
			t.join();
		}

	}

	//处理请求和应答
	
	template <typename socket_type>
	void ServerBase<socket_type>::process_request_and_respond(std::shared_ptr<socket_type> socket)const{
		auto read_buffer = std::make_shared<boost::asio::streambuf>();//read buffer

		boost::asio::async_read_until(*socket,*read_buffer,"\r\n\r\n",
				[this,socket,read_buffer](const boost::system::error_code &ec,
					size_t bytes_transferred){
				if(!ec){
				size_t total = read_buffer->size();
				std::istream stream(read_buffer.get());
				auto request = std::make_shared<Request>();
				
				*request = parse_request(stream);
				size_t num_additional_bytes = total - bytes_transferred;

				if(request->header.count("Content_Length")>0){
				boost::asio::async_read(*socket,*read_buffer,
						boost::asio::transfer_exactly(stoull(request->header["Content_Length"])-num_additional_bytes),
						[this,socket,read_buffer,request](boost::system::error_code & ec,size_t bytes_transferred){
						if(!ec){
							request->content = std::shared_ptr<std::istream>(new std::istream(read_buffer.get()));
							respond(socket,request);
						}
						});
				}else{
					respond(socket,request);
				}
			}				
			});
		}
		//解析请求
	template <typename socket_type>
		Request ServerBase<socket_type>::parse_request(std::istream& stream)const{
			Request request;
			
			//对请求头进行解析
            std::regex e("^([^ ]*) ([^ ]*) HTTP/([^ ]*)$");
			std::smatch sub_match;
			//从第一行中解析请求方法，路径和HTTP版本
			std::string line;
			getline(stream, line);
			line.pop_back();
			if(std::regex_match(line,e)){
				request.method = sub_match[1];
				request.path = sub_match[2];
				request.http_version = sub_match[3];

				//解析头部其他信息
				bool matched;
                e="^([^:]*): ?(.*)$";
				do{
					getline(stream,line);
					line.pop_back();
					matched = std::regex_match(line,sub_match,e);
					if(matched){
						request.header[sub_match[1]] = sub_match[2];
					}
				}while(matched == true);
			}
			return request;
		}
		
	template <typename socket_type>
		void ServerBase<socket_type>::respond(std::shared_ptr<socket_type> socket, std::shared_ptr<Request> request)const{
			//对请求路径和方法进行匹配查找，并生成相应
			for(auto res_it:all_resources){
				std::regex e(res_it->first);
				std::smatch sm_res;
				if(std::regex_match(request->path, sm_res, e)){
					if(res_it->second.count(request->method)>0){
						request->path_match = move(sm_res);
						auto write_buffer = std::make_shared<boost::asio::streambuf>();
						std::ostream response(write_buffer.get());
						res_it->second[request->method](response, *request);

						boost::asio::async_write(*socket, *write_buffer, 
								[this,socket,request,write_buffer](const boost::system::error_code &ec, size_t bytes_transferred){
								if(!ec && stof(request->http_version)>1.05)
									process_request_and_respond(socket);//递归调用
								});
						return;

					}
				}
			}
		}
		template <typename socket_type>
		class Server:public ServerBase<socket_type>{

		};

}
#endif	/*server_base_hpp*/
